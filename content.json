{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com"},"pages":[],"posts":[{"title":"Vagrant安装虚拟机及常用命令","slug":"Vagrant安装虚拟机及常用命令","date":"2022-11-18T15:42:42.000Z","updated":"2022-11-19T04:53:13.293Z","comments":false,"path":"2022/11/18/Vagrant安装虚拟机及常用命令/","link":"","permalink":"http://example.com/2022/11/18/Vagrant%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Vagrant安装虚拟机通过网络或者本地添加镜像，添加成功之后初始化，然后启动、连接 1234567vagrant box add --name centos-7 D://Centos-7.box #本地添加vagrant box add --name centos-7 centos/7 #网络下载vagrant box list # 查看镜像是否添加成功vagrant init centos-7 #初始化环境，此处虚拟机名称必须和添加时名称一致，否则可能会报错vagrant up #启动虚拟机vagrant ssh #连接虚拟机 Vagrant常用命令123456789101112131415161718192021222324252627282930vagrant --version # 查看 vagrant 版本vagrant box list # 查看 box 列表vagrant box add [boxname] [url] # 添加 boxvagrant box remove [boxname] # 移除 boxvagrant box update # 更新 boxvagrant box repackage [name|id] --output [name] # 打包 boxvagrant init [name [url]] # 初始化，生成 Vagrantfilevagrant up [name|id] # 启动虚拟机vagrant halt [name|id] # 关闭虚拟机vagrant reload [name|id] # 重启虚拟机vagrant reload --provision # 重新加载部分 Vagrantfile 中的配置项vagrant suspend [name|id] # 挂起虚拟机vagrant resume [name|id] # 唤醒挂起的虚拟机vagrant destory [name|id] # 销毁虚拟机vagrant status [name|id] # 查看虚拟机状态vagrant global-status # 查看所有虚拟机的状态vagrant port [name|id] # 查看端口映射vagrant validate # 校验 Vagrantfilevagrant ssh [name|id] # 进入虚拟机vagrant ssh-config [name|id] # 查看 ssh 配置vagrant snapshot list # 查看快照列表vagrant snapshot push # 状态入栈vagrant snapshot pop # 状态弹栈vagrant snapshot save [vm-name] [NAME] # 保存一个快照，不要与 push 和 pop 混合使用vagrant snapshot restore [vm-name] [NAME] # 恢复指定快照vagrant snapshot delete [vm-name] [NAME] # 删除一个快照 Vagrantfile配置 单机配置 12345678910111213141516Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;centos7&quot; # box 名称 config.vm.hostname = &quot;centos7&quot; # 虚拟机主机名 shell 中显示 config.vm.define &quot;centos7&quot; # vagrant 状态查询中显示名字 config.vm.box_check_update = false # 盒子不检查更新 # 配置成私有网络，类似主机模式 config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; # 虚拟机供应者参数配置，相当于在 virtualbox 中配置 config.vm.provider &quot;virtualbox&quot; do |vb| vb.gui = false # 启动机器时显示 VirtualBox GUI vb.name = &quot;centos7&quot; # 虚拟机名称，virtualbox gui 中显示 vb.memory = 2048 # 虚拟机存储大小，mb vb.cpus = 2 # cpu 大小 endend 集群配置 12345678910111213141516171819Vagrant.configure(&quot;2&quot;) do |config| config.vm.define :web do |web| web.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;web&quot;, &quot;--memory&quot;, &quot;512&quot;] end web.vm.box = &quot;CentOs7&quot; web.vm.hostname = &quot;web&quot; web.vm.network :private_network, ip: &quot;192.168.33.10&quot; end config.vm.define :redis do |redis| redis.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;redis&quot;, &quot;--memory&quot;, &quot;512&quot;] end redis.vm.box = &quot;CentOs7&quot; redis.vm.hostname = &quot;redis&quot; redis.vm.network :private_network, ip: &quot;192.168.33.11&quot; endend 使用以下命令登录相关机器 1vagrant ssh redis / web 配置客户端工具[如XShell]连接 备注：Vagrant默认只能通过公私钥进行客户端连接,可通过如下命令查看私钥存放的位置 1vagrant ssh-config 修改默认root账号密码：输入以下命令，并根据提示输入新密码和确认密码 12sodo passwd rootsu root # 切换root用户 编辑配置文件sshd_config，并修改相关属性后重启sshd服务 123456vi /etc/ssh/sshd_configPermitRootLogin yes # 允许直接通过root账号登录PasswordAuthentication yes # 可以通过密码登录systemctl restart sshd #重启sshd服务 修改vagrantfile文件,并重启虚拟机，之后就可以通过Xshell连接服务器 12345onfig.ssh.username = &#x27;root&#x27;config.ssh.password = &#x27;root&#x27; #注意如果没有修改密码默认是vagrantconfig.ssh.insert_key = false #是否通过公私钥来登录虚拟机，默认为true,如果为True,可能会出现一直Warning: Authentication failure. Retrying...vagrant reload # 重启虚拟机 相关链接虚拟机镜像下载地址 Vagrant官方文档","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Vagrant","slug":"Vagrant","permalink":"http://example.com/tags/Vagrant/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"雪花ID生成工具","slug":"雪花ID生成工具","date":"2022-10-06T10:42:42.000Z","updated":"2022-10-08T13:22:55.445Z","comments":false,"path":"2022/10/06/雪花ID生成工具/","link":"","permalink":"http://example.com/2022/10/06/%E9%9B%AA%E8%8A%B1ID%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import org.springframework.stereotype.Component;import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;@Componentpublic class IdWorker &#123; /** * 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） */ private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // /** * 机器ID最大值 */ private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** * 数据中心ID最大值 */ private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** * 毫秒内自增位 */ private final static long sequenceBits = 12L; /** * 机器ID偏左移12位 */ private final static long workerIdShift = sequenceBits; /** * 数据中心ID左移17位 */ private final static long datacenterIdShift = sequenceBits + workerIdBits; /** * 时间毫秒左移22位 */ private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; /** * 0，并发控制 */ private long sequence = 0L; private final long workerId; /** * 数据标识id部分 */ private final long datacenterId; public IdWorker() &#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** * @param workerId 工作机器ID * @param datacenterId 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException( String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException( String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** * 获取下一个ID * * @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format( &quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* * GET jvmPid */ mpid.append(name.split(&quot;@&quot;)[0]); &#125; /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot; getDatacenterId: &quot; + e.getMessage()); &#125; return id; &#125;&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"雪花ID","slug":"雪花ID","permalink":"http://example.com/tags/%E9%9B%AA%E8%8A%B1ID/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"sping logback配置","slug":"logback-spring","date":"2022-10-05T05:42:42.000Z","updated":"2022-10-08T13:35:00.078Z","comments":false,"path":"2022/10/05/logback-spring/","link":"","permalink":"http://example.com/2022/10/05/logback-spring/","excerpt":"","text":"logback日志配置文件：logback-spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot;&gt; &lt;!--定义日志文件的存储地址 --&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot;/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt; &lt;!--&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%L - %msg%n&lt;/pattern&gt;--&gt; &lt;pattern&gt;%d&#123;MM-dd HH:mm:ss.SSS&#125;[%-5p][%-21t] %m%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/app.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件输出的文件名 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/app-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数 --&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;totalSizeCap&gt;5GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%L - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--myibatis log configure --&gt; &lt;logger name=&quot;com.apache.ibatis&quot; level=&quot;TRACE&quot;/&gt; &lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot;/&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"logback","slug":"logback","permalink":"http://example.com/tags/logback/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"CenterOS中间件开机自启动","slug":"CenterOS中间件开机自启动","date":"2022-10-04T10:35:44.000Z","updated":"2022-10-08T13:51:06.752Z","comments":false,"path":"2022/10/04/CenterOS中间件开机自启动/","link":"","permalink":"http://example.com/2022/10/04/CenterOS%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"","text":"redis在&#x2F;etc&#x2F;init.d&#x2F;目录下新建redis相关命令脚本redis 12345cd /etc/init.d/ &amp;&amp; touch redis#编辑redisvim redis#参考以下代码 12345678910111213141516171819202122#!/bin/bashREDIS_HOME=/usr/local/redisIP=127.0.0.1PORT=6379PASSWORD=***case $1 in start) $&#123;REDIS_HOME&#125;/bin/redis-server $&#123;REDIS_HOME&#125;/conf/redis.conf ;; stop) $&#123;REDIS_HOME&#125;/bin/redis-cli -h $&#123;IP&#125; -p $&#123;PORT&#125; -a $&#123;PASSWORD&#125; shutdown 2&gt;/dev/null ;; restart) $&#123;REDIS_HOME&#125;/bin/redis-cli -h $&#123;IP&#125; -p $&#123;PORT&#125; -a $&#123;PASSWORD&#125; shutdown 2&gt;/dev/null $&#123;REDIS_HOME&#125;/bin/redis-server $&#123;REDIS_HOME&#125;/conf/redis.conf ;; *) echo &#x27;please use : redis &#123;start | stop | restart&#125;&#x27; ;;esacexit 0 注： 添加 2&gt;&#x2F;dev&#x2F;null 的目的是将在命令行使用密码的警告去除，若redis没有开启认证，则不需要 -a 参数及后边错误输出 1234567#赋予脚本可执行权限chmod +x redis#测试脚本是否成功启动、关闭、重启redis服务service redis start #开启service redis stop #关闭service redis restart #重启 设置开机自启动 123456#1.添加系统服务chkconfig --add redis#2.开机自启动chkconfig redis on#3.查看chkconfig --list 如下图所示，redis已加入开机自启动，重启机器测试redis有没有自启动 nginx步骤参考redis，脚本如下 12345678910111213141516171819202122232425262728293031#!/bin/bash# description: nginx Start Stop Reload# processname: nginx# chkconfig: 2345 20 80NGINX_HOME=/usr/local/nginxNGINX_PID=/usr/local/nginx/logs/nginx.pidcase $1 in start) if [ -f $&#123;NGINX_PID&#125; ];then echo &quot;nginx服务处于开启状态&quot; else $NGINX_HOME/sbin/nginx fi ;; stop) if [ ! -f $&#123;NGINX_PID&#125; ];then echo &quot;nginx服务已经关闭&quot; else $NGINX_HOME/sbin/nginx -s stop fi ;; reload) $NGINX_HOME/sbin/nginx -s reload ;; *) echo &#x27;please use : nginx &#123;start | stop | reload&#125;&#x27; ;;esacexit 0 zookeeper1234567891011121314151617181920#!/bin/bash#chkconfig:2345 20 90#description:zookeeper#processname:zookeeperexport JAVA_HOME=/opt/lft/jdk-17.0.1ZOOKEEPER_SERVER=/usr/local/zookeeper-3.6.3/bin/zkServer.shcase $1 in start) su root $&#123;ZOOKEEPER_SERVER&#125; start;; stop) su root $&#123;ZOOKEEPER_SERVER&#125; stop;; status) su root $&#123;ZOOKEEPER_SERVER&#125; status;; restart) su root $&#123;ZOOKEEPER_SERVER&#125; restart;; *) echo &quot;require start|stop|status|restart&quot; ;;esac mysql","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"自启动","slug":"自启动","permalink":"http://example.com/tags/%E8%87%AA%E5%90%AF%E5%8A%A8/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2022-10-04T04:30:44.000Z","updated":"2022-10-04T05:16:46.716Z","comments":true,"path":"2022/10/04/设计模式-单例模式/","link":"","permalink":"http://example.com/2022/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"懒汉式线程不安全懒汉式基本概念：当真正需要获取到该对象时，才会创建该对象 该写法存在线程安全性问题 12345678910111213141516public class Singleton &#123; //实例化的变量引用私有化 private static Singleton singleton = null; /** * 私有化构造函数 */ private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 懒汉式线程安全1234567891011121314151617public class Singleton &#123; //实例化的变量引用私有化 private static Singleton singleton = null; /** * 私有化构造函数 */ private Singleton() &#123;&#125; // 创建和读取对象都需要获取Singleton01 锁 public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 懒汉式双重检验1234567891011121314151617181920public class Singleton &#123; //实例化的变量引用私有化 private static volatile Singleton singleton = null; /** * 私有化构造函数 */ private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 饿汉式提前创建单例对象，优点先天性保证线程安全，比较占用内存 12345678910111213public class Singleton &#123; // 当我们class被加载时，就会提前创建singleton对象 private static Singleton singleton = new Singleton(); /** * 私有化构造函数 */ private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 静态代码块1234567891011121314151617public class Singleton &#123; // 当我们class被加载时，就会提前创建singleton对象 private static Singleton singleton = null; static &#123; singleton = new Singleton(); &#125; /** * 私有化构造函数 */ private Singleton05() &#123;&#125; public static Singleton05 getInstance() &#123; return singleton; &#125;&#125; 静态内部类1234567891011121314public class Singleton &#123; /** * 私有化构造函数 */ private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static Singleton singleton = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.singleton; &#125;&#125; 枚举单例枚举属于目前最安全的单例，不能够被反射序列化 破解 保证单例 1234567891011121314151617181920212223public class Singleton &#123; //私有化构造函数 private Singleton()&#123; &#125; //定义一个静态枚举类 static enum SingletonEnum&#123; //创建一个枚举对象，该对象天生为单例 INSTANCE; private Singleton singleton; //私有化枚举的构造函数 private SingletonEnum()&#123; singleton = new singleton(); &#125; public singleton getInstnce()&#123; return singleton; &#125; &#125; //对外暴露一个获取User对象的静态方法 public static Singleton getInstance()&#123; return SingletonEnum.INSTANCE.getInstnce(); &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"Mysql索引总结","slug":"Mysql索引总结","date":"2022-10-03T14:35:44.000Z","updated":"2022-10-04T05:16:28.485Z","comments":true,"path":"2022/10/03/Mysql索引总结/","link":"","permalink":"http://example.com/2022/10/03/Mysql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"索引定义 索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。 索引类型 Mysql中根据 索引中是否存在数据，将索引分为了两种类型的索引：聚簇索引和非聚簇索引。 聚簇索引 聚簇索引是在索引树的叶子节点中保存了完整的数据信息，则索引称为聚簇索引。Mysql的 InnoDB引擎为主键创建的主键索引即是聚簇索引，数据文件即是索引文件。MyIsam引擎中的主键索引也是非聚簇索引。 非聚簇索引 非聚簇索引是指索引树的叶子节点中保存的不是完整的数据信息，而是指向数据的一个指针或者是地址信息等（MyIsam的主键索引是指向数据的地址信息，InnoDB 中是主键的Id）。如果需要获取全部的数据信息，需要进行一次回表的操作。 联合索引 联合索引是同时对多个列创建的索引。索引树中的叶子节点会同时包含多个列的值，叶子节点之间的排序，会根据创建索引时候列的顺序排序，排序满足最左前缀规则。 最左前缀规则：例如当存在一个联合索引，包括了A、B、C三列的时候，如果查询是使用了 A、【A、B】、【A、B、C】的查询方式，则可以使用这个索引，如果是 使用了 【B、C】作为查询条件，则不满足最左前缀原则，则不会使用这个索引。 因为Mysql在创建联合索引的时候，是先去比较第一列的值，当第一列的值相同的时候，才会比较第二列的值，当第二列的值相同的时候，再去比较第三列的值，以此类推，直到最后的一列。所以，当跳过第一列的值，直接匹配第二列的时候，此时第二列的值不一定是有序的，所以无法使用。 覆盖索引 当使用某个查询条件的时候，如果需要查询的所有字段在索引中已经存在，即可直接返回，不用再根据查询到的主键ID进行回表操作，称为覆盖索引。 如果我们为name和age 创建了一个索引。当我们查询name为指定值的数据的age 和Id的时候，就会使用覆盖索引。因为在索引数据已经存在了 name 和 age 的值（主键ID的值是每一个索引都会存在的），不会再根据id回表聚簇索引查询数据。 如果在索引中不存在查询的字段数据信息，则会在查找到满足条件的数据之后，会根据查找到数据的主键ID，回表聚簇索引查找其他的信息，最终返回数据。 唯一索引 唯一索引要求指定的列的值不能存在相同的值，数据库在每一次进行添加或者修改的时候，都会进行数据的检查，如果数据存在了重复的值，则会直接返回失败。 索引原理 Mysql的数据，在索引树中存储的基本单位是页，即多个Mysql的数据项（暂且把用户数据和目录数据均称为数据项）组成了一个 页。当页的大小用完的时候，就会分裂出一个新的列，然后使用指针和之前的列连接起来，形成一个链表。 因为这些节点在内存中的位置不一定是连续的，如果想要快速的从内存中找到对应的数据，就需要为这些数据创建一个目录，每一页对应一个目录项。然后再将目录项组装成一个 页，也就形成了如下的格式： 目录项中记录的每一个数据页中的最小值以及页号，就可以通过比较值的大小，找到对应的页，就可以快速的定位到对应的数据。 当目录页中的空间地址不足的时候，就分裂目录页，然后和数据页一样，使用指针将两个目录页串联起来，形成一个双向链表。 以此类推，直到形成一个根目录（实际创建的时候，是先有的根目录，然后再慢慢的增加后续的目录页和数据页）。然后就形成了一棵B+树。查询的时候，就可以通过比较根目录中记录的Id 的大小，找到对应的Id 所在的下一级目录页，然后以此类推找到最终的叶子节点，就可以快速的找到对应的数据。 所以从上述的过程中发现，创建的主键Id，最好是选用自增的ID，因为自增ID的顺序只需要在最后追加即可，如果是非规则的数据，可能下一次的id顺序比之前的都小，Mysql为了维护id的顺序，则会进行数据的移动，就会涉及到数据的迁移以及页的分裂等。 索引失效 索引失效是指为数据列创建了索引，但是在使用的时候，虽然使用了索引列，但是索引的作用不会生效，最终查询的时候，不会使用索引树进行查询。 索引失效的条件 索引列上的操作 类型转换 ​ 计算 like查询以”%”开头 因为Mysql在比较字符串的时候，是根据字符串从左到右做比较，满足最左匹配原则，当使用”%”开头查询的时候，就会破坏最左原则，所以不能使用索引。 破坏最左前缀原则：联合索引查询的时候，如果不满足最左前缀原则，则不会使用索引 范围查询的右边索引会失效 当有A、B、C三个联合索引的时候，如果where A &#x3D; 123 and B &gt; 20 and C &#x3D; 456;则C的索引会失效。因为 B 会返回多个值，会根据返回的多个值再去做匹配查询。因为在多个值的情况下，C的排序未必是有序的，可能是乱序的情况，无法使用索引。 or 查询 or 查询会产生多条数据，这多个数据之间排序规则是不确定的。 使用 ≠ 做判断 字符串没有加单引号：会发生类型的隐式转换 估计全表扫描会比索引快 排序产生filesort的原因 当对查询需要进行的排序的时候，如果排序的字段没有使用索引，或者不满足最左前缀原则，则会使用文件排序的方式，来完成排序。 为什么索引使用的数据结构是B+树，而不是二叉树或者是B树 使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B+树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。 为什么选择了B+ 树而不是B树 B树的特点是每一个节点中都会存储key和数据，而B+树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。 B树的叶子节点之间是独立的，B+树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。 B树的查询效率不稳定，B+树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的额数据之后，就会返回数据信息，不会走到叶子节点。但是B+树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。 因为B+树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"zabbix 监控 zookeeper","slug":"zabbix-监控-zookeeper","date":"2022-10-02T05:44:20.000Z","updated":"2022-10-04T05:16:40.469Z","comments":true,"path":"2022/10/02/zabbix-监控-zookeeper/","link":"","permalink":"http://example.com/2022/10/02/zabbix-%E7%9B%91%E6%8E%A7-zookeeper/","excerpt":"","text":"zookeeper配置由于需要使用zookeeper的四字命令，所以需要修改zookeeper的配置，修改 &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;conf&#x2F;zoo.cfg （根据自己zookeeper位置进行修改）如下所示： 14lw.commands.whitelist=* 使用zookeeper四字命令需要先安装 nc 或者 telnet,命令如下： 123$ yum install nc # centos或$ sudo apt install netcat # ubuntu 四字命令语法如下： 1234567891011121314151617echo [command] | nc [ip] [port]# 常用四字命令如下# conf 3.3.0版本引入的。打印出服务相关配置的详细信息。# cons 3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括&quot;接受/发送&quot;的包数量、会话id、操作延迟、最后的操作执行等等信息。# crst 3.3.0版本引入的。重置所有连接的连接和会话统计信息。# dump 列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。# envi 打印出服务环境的详细信息。# reqs 列出未经处理的请求# ruok 测试服务是否处于正确状态。如果确实如此，那么服务返回&quot;imok&quot;，否则不做任何相应。# stat 输出关于性能和连接的客户端的列表。# srst 重置服务器的统计。# srvr 3.3.0版本引入的。列出连接服务器的详细信息# wchs 3.3.0版本引入的。列出服务器watch的详细信息。# wchc 3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。# wchp 3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。# mntr 3.4.0版本引入的。输出可用于检测集群健康状态的变量列表 修改完成后重启zookeeper服务，命令如下： 1234567cd /usr/local/software/zookeeper/zookeeper #切换到zookeeper目录./bin/zkServer.sh restart #重启# 相关命令# ./bin/zkServer.sh start #启动# ./bin/zkServer.sh status #状态# ./bin/zkServer.sh stop #停止 注意，zookeeper相关端口是否开放，相关命令可参考 linux 常用命令 监控项1234567891011121314151617zk_avg/min/max_latency 响应一个客户端请求的时间，建议这个时间大于10个Tick就报警zk_outstanding_requests 排队请求的数量，当ZooKeeper超过了它的处理能力时，这个值会增大，建议设置报警阀值为10zk_packets_received 接收到客户端请求的包数量zk_packets_sent 发送给客户单的包数量，主要是响应和通知zk_max_file_descriptor_count 最大允许打开的文件数，由ulimit控制zk_open_file_descriptor_count 打开文件数量，当这个值大于允许值得85%时报警Mode 运行的角色，如果没有加入集群就是standalone,加入集群式follower或者leaderzk_followers leader角色才会有这个输出,集合中follower的个数。正常的值应该是集合成员的数量减1zk_pending_syncs leader角色才会有这个输出，pending syncs的数量zk_znode_count znodes的数量zk_watch_count watches的数量zk_ruok zookeeper server状态，运行状态imokzk_version zookeeper 版本zk_num_alive_connections 连接数zk_min_latency 数据传输最小延迟zk_max_latency 数据传输最大延迟zk_avg_latency 数据传输平均延迟 监控配置切换到zabbix-agent的配置文件所在目录 1234567891011121314151617181920212223242526272829303132333435363738cd /etc/zabbix# 新建脚本保存文件mkdir scripts &amp;&amp; cd scripts# 新建zookeeper监控脚本touch zookeeper_mntr.shvi zookeeper_mntr.sh#参考如下代码#!/bin/bash#serverZOOKEEPER_SERVER=192.168.XX.XXX# 端口ZOOKEEPER_PORT=2181# 参数ZOOKEEPER_METRIC=$1if [ $&#123;ZOOKEEPER_METRIC&#125; == &quot;zk_version&quot; ];then echo mntr |nc $&#123;ZOOKEEPER_SERVER&#125; $&#123;ZOOKEEPER_PORT&#125;|grep $&#123;ZOOKEEPER_METRIC&#125;|awk -F&#x27; &#x27; &#x27;&#123;print $2&#125;&#x27; |awk -F&#x27;-&#x27; &#x27;&#123;print $1&#125;&#x27;else echo mntr |nc $&#123;ZOOKEEPER_SERVER&#125; $&#123;ZOOKEEPER_PORT&#125;|grep $&#123;ZOOKEEPER_METRIC&#125;|awk -F&#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;fi#保存退出编辑touch zookeeper_ruok.shvi zookeeper_ruok.sh#参考如下代码#!/bin/bash#serverZOOKEEPER_SERVER=192.168.75.244# 端口ZOOKEEPER_PORT=2181echo ruok |nc $&#123;ZOOKEEPER_SERVER&#125; $&#123;ZOOKEEPER_PORT&#125;#保存退出编辑# 赋予脚本可执行权限chmod +x zookeeper_mntr.shchmod +x zookeeper_ruok.sh 在&#x2F;etc&#x2F;zabbix&#x2F;zabbix_agent.d目录下新建userParameter_zookeeper.conf文件 1234567cd /etc/zabbix/zabbix_agent.dmkdir userParameter_zookeeper.convi userParameter_zookeeper.con#粘贴以下代码UserParameter=zookeeper.mntr[*],sh /etc/zabbix/scripts/zookeeper_mntr.sh $1UserParameter=zookeeper.ruok[*],sh /etc/zabbix/scripts/zookeeper_ruok.sh $1#保存退出编辑 模板参考 zbx_zookeeper_template","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"zabbix","slug":"zabbix","permalink":"http://example.com/tags/zabbix/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://example.com/tags/zookeeper/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"Linux 常用命令","slug":"Linux-常用命令","date":"2022-10-02T05:42:42.000Z","updated":"2022-10-08T13:12:14.332Z","comments":true,"path":"2022/10/02/Linux-常用命令/","link":"","permalink":"http://example.com/2022/10/02/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"防火墙相关1. firewalld的基本使用 1234systemctl start firewalld #启动systemctl status firewalld #查看状态systemctl stop firewalld #停止systemctl disable firewalld #禁用 2. 配置firewalld-cmd 1234567891011121314firewall-cmd --version #查看版本firewall-cmd --help #查看帮助firewall-cmd --state #显示状态firewall-cmd --zone=public --list-ports #查看所有打开的端口firewall-cmd --reload #更新防火墙规则firewall-cmd --get-active-zones #查看区域信息firewall-cmd --get-zone-of-interface=eth #查看指定接口所属区域 firewall-cmd --panic-on #拒绝所有包firewall-cmd --panic-off #取消拒绝状态firewall-cmd --query-panic #查看是否拒绝firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） #开放端口firewall-cmd --reload #重新载入firewall-cmd --zone= public --query-port=80/tcp #查看firewall-cmd --zone= public --remove-port=80/tcp --permanent #移除 3.端口 1234567891011121314#查看端口占用情况lsof -i:端口号或netstat -tnlp | grep 端口号-a：显示本机所有连接和监听地端口-n：网络IP地址的形式，显示当前建立的有效连接和端口-r：显示路由表信息-s：显示按协议的统计信息-v：显示当前有效的连接-t：显示所有TCP协议连接情况-u：显示所有UDP协议连接情况-i：显示自动配置端口的状-l：仅仅显示连接状态为listening的服务网络状态-p：显示pid/program name 压缩解压在 Linux 中常见压缩格式有十几种，比如：”.zip”、”.gz”、”.bz2”、“tar”、”.tar.gz”、”.tar.bz2”等等 .zip 1234567891011#压缩zip [选项] 压缩包名 源文件或源目录选项：​ -r：压缩目录zip mytxt.zip a.txt a.txt c.txt #将a,b,c压缩在mytext.zip中#解压unzip [选项] 压缩包名选项：​ -d：指定解压缩位置 如果不指定 -d 参数，默认解压到当前目录下unzip -d /usr/local/doc/ mytxt.zip #将mytext解压到/usr/local/doc/目录 .tar 123456789101112131415#压缩tar [选项] [-f 压缩包名] 源文件或目录选项：​ -c：打包​ -f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名。​ -v：显示打包文件过程tar -cvf mytxt.tar a.txt b.txt c.text#解压tar [选项] 压缩包选项：​ -x：解打包​ -f：指定压缩包的文件名​ -v：显示解打包文件过程tar -xvf mytxt.tar .gz [只能压缩，不能打包] 12345678910111213#压缩gzip [选项] 源文件选项：​ -c：将压缩数据输出到标准输出中，可以用于保留源文件​ -d：解压缩​ -r：压缩目录gzip 压缩文件后会把源文件删除掉，它是不支持保留源文件的 使用 gzip -r 目录 命令，它是把这个目录下的所有文件都压缩，而不会把这个目录压缩(不能打包)gzip abc.txt #压缩abc.txt文件，之后删除源文件#解压gzip -d 压缩包名或gunzip 压缩包名 .tar.gz 和 .tar.bz2”格式 1234567891011121314151617181920#压缩tar [选项] 压缩包 源文件或目录选项：​ -z：压缩和解压缩 &quot;.tar.gz&quot; 格式​ -j： 压缩和解压缩 &quot;.tar.bz2&quot; 格式tar -jcvf test.gz.bz2 a.txt b.txt c.txttar -zcvf test.tar.gz aa.txt b.txt #解压tar -jxvf test.gz.bz2 tar -zxvf test.tar.gz # 只查看不解压tar -ztvf test.tar.gz # 解压到指定目录(-C 一定要跟在压缩包后面)tar -zxvf test.tar.gz -C /usr/local/doc/# 解压指定文件tar -ztvf test.tar.gz tar -zxvf test.tar.gz -C /usr/local/doc a.text #将压缩包中a.text解压到/usr/local/doc目录 chkconfiglinux 运行级别 运行级别就是操作系统当前正在运行的功能级别。这个级别从0到6 ，具有不同的功能。这些级别在&#x2F;etc&#x2F;inittab文件里指定。这个文件是init程序寻找的主要文件，最先运行的服务是那些放在&#x2F;etc&#x2F;rc.d 目录下的文件。 不同的运行级定义如下：(可以参考Linux里面的&#x2F;etc&#x2F;inittab) # 缺省的运行级，RHS用到的级别如下： ​ 0：关机 ​ 1：单用户模式 ​ 2：无网络支持的多用户模式 ​ 3：有网络支持的多用户模式 ​ 4：保留，未使用 ​ 5：有网络支持有X-Window支持的多用户模式 ​ 6：重新引导系统，即重启 对各个运行级的详细解释： ​ 0 为停机，机器关闭。 ​ 1 为单用户模式，就像Win9x下的安全模式类似。 ​ 2 为多用户模式，但是没有NFS支持。 ​ 3 为完整的多用户模式，是标准的运行级。 ​ 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本 电脑的电池用尽时，可以切换到这个模式来做一些设置。 ​ 5 就是X11，进到X Window系统了。 ​ 6 为重启，运行init 6机器就会重启。 chkconfig命令可以用来检查、设置系统的各种服务 使用语法： 123456789chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset]参数用法：–add 增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。–del 删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。–level&lt;等级代号&gt; 指定读系统服务要在哪一个执行等级中开启或关毕。 使用范例： 1234567chkconfig –-list #列出所有的系统服务chkconfig –-add redis #增加redis服务chkconfig –-del redis #删除redis 服务chkconfig –-level redis 2345 on #把redis在运行级别为2、3、4、5的情况下都是on（开启）的状态。 wcwc命令 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数。若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。 语法： 123wc(选项)(参数)wc [选项]... [文件]...wc [选项]... --files0-from=F 选项： 12345-c # 统计字节数，或--bytes或——chars：只显示Bytes数；。-l # 统计行数，或——lines：只显示列数；。-m # 统计字符数。这个标志不能与 -c 标志一起使用。-w # 统计字数，或——words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。-L # 打印最长行的长度。","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]}]}